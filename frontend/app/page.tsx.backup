'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { apiClient, Text, AnalysisSummary } from '@/lib/api';
import { useAnalysisStore } from '@/lib/store';
import { useAuth } from '@/lib/useAuth';
import classNames from 'classnames';
import Navigation from '@/components/Navigation';

export default function HomePage() {
  const router = useRouter();
  const { analyses, setAnalyses, addAnalysis, updateAnalysis, startPolling, stopPolling, stopAllPolling } = useAnalysisStore();
  const { isAuthenticated, isLoading } = useAuth();
  
  const [texts, setTexts] = useState<Text[]>([]);
  const [filteredTexts, setFilteredTexts] = useState<Text[]>([]);
  const [selectedTextId, setSelectedTextId] = useState<string>('');
  const [customText, setCustomText] = useState('');
  const [grade, setGrade] = useState<string>('');
  
  const [isUploading, setIsUploading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [showSuccess, setShowSuccess] = useState(false);
  const [formErrors, setFormErrors] = useState({
    file: '',
    text: '',
    grade: ''
  });

  // Load data when authenticated
  useEffect(() => {
    if (isAuthenticated) {
      loadTexts();
      loadAnalyses();
    }
    
    // Cleanup polling on unmount
    return () => {
      stopAllPolling();
    };
  }, [isAuthenticated]);

  // Filter texts by grade
  useEffect(() => {
    if (grade && grade !== '') {
      const filtered = texts.filter(t => t.grade === parseInt(grade));
      setFilteredTexts(filtered);
    } else {
      setFilteredTexts(texts);
    }
  }, [grade, texts]);

  // Update customText when a text is selected
  useEffect(() => {
    if (selectedTextId && texts.length > 0) {
      const selectedText = texts.find(t => t.id === selectedTextId);
      if (selectedText) {
        setCustomText(selectedText.body);
        // Don't override user's grade selection
        // setGrade(selectedText.grade);
      }
    }
  }, [selectedTextId, texts]);

  const loadTexts = useCallback(async () => {
    try {
      const textsData = await apiClient.getTexts();
      setTexts(textsData);
    } catch (error) {
      console.error('Failed to load texts:', error);
    }
  }, []);

  const loadAnalyses = useCallback(async () => {
    try {
      const analysesData = await apiClient.getAnalyses(20);
      setAnalyses(analysesData);
      
      // Start polling for running/queued analyses
      analysesData.forEach(analysis => {
        if (analysis.status === 'running' || analysis.status === 'queued') {
          startPolling(analysis.id, async () => {
            try {
              const updatedAnalysis = await apiClient.getAnalysis(analysis.id);
              updateAnalysis(analysis.id, { status: updatedAnalysis.status });
              
              if (updatedAnalysis.status === 'done' || updatedAnalysis.status === 'failed') {
                // Reload full analysis data
                updateAnalysis(analysis.id, updatedAnalysis);
                stopPolling(analysis.id);
              }
            } catch (error) {
              console.error(`Failed to poll analysis ${analysis.id}:`, error);
              stopPolling(analysis.id);
            }
          });
        }
      });
    } catch (error) {
      console.error('Failed to load analyses:', error);
    }
  }, [setAnalyses, startPolling, updateAnalysis, stopPolling]);

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const file = e.dataTransfer.files[0];
      validateAndSetFile(file);
    }
  };

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      validateAndSetFile(file);
    }
  };

  // File validation
  const validateAndSetFile = (file: File) => {
    const errors = { ...formErrors };
    
    // File size check (max 50MB)
    if (file.size > 50 * 1024 * 1024) {
      errors.file = 'Dosya boyutu 50MB\'dan büyük olamaz';
      setFormErrors(errors);
      return;
    }
    
    // File type check
    const allowedTypes = ['audio/mpeg', 'audio/wav', 'audio/mp4', 'audio/m4a', 'audio/x-m4a'];
    if (!allowedTypes.includes(file.type)) {
      errors.file = 'Desteklenmeyen dosya türü. MP3, WAV, M4A dosyaları kabul edilir.';
      setFormErrors(errors);
      return;
    }
    
    // Clear file error and set file
    errors.file = '';
    setFormErrors(errors);
    setSelectedFile(file);
  };

  // Sanitize input
  const sanitizeInput = (input: string) => {
    return input
      .trim()
      .replace(/[<>]/g, '') // Remove potential HTML tags
      .replace(/javascript:/gi, '') // Remove javascript: protocol
      .replace(/on\w+=/gi, ''); // Remove event handlers
  };

  // Form validation
  const validateForm = () => {
    const errors = { file: '', text: '', grade: '' };
    let isValid = true;

    // File validation
    if (!selectedFile) {
      errors.file = 'Ses dosyası seçilmelidir';
      isValid = false;
    }

    // Text validation
    if (!customText.trim()) {
      errors.text = 'Hedef metin gereklidir';
      isValid = false;
    } else if (customText.trim().length < 10) {
      errors.text = 'Hedef metin en az 10 karakter olmalıdır';
      isValid = false;
    } else if (customText.trim().length > 10000) {
      errors.text = 'Hedef metin en fazla 10,000 karakter olabilir';
      isValid = false;
    }

    // Grade validation
    if (!grade || grade === '' || ![1, 2, 3, 4].includes(parseInt(grade))) {
      errors.grade = 'Geçerli bir sınıf seviyesi seçilmelidir';
      isValid = false;
    }

    setFormErrors(errors);
    return isValid;
  };


  const startAnalysis = async () => {
    // Validate form before proceeding
    if (!validateForm()) {
      return;
    }
    
    setIsUploading(true);
    try {
      // Sanitize custom text
      const sanitizedText = sanitizeInput(customText);
      
      // Create a temporary text if using custom text
      let textId = selectedTextId;
      if (!selectedTextId && sanitizedText.trim()) {
        const tempText = await apiClient.createText({
          title: `Geçici Metin - ${new Date().toLocaleString('tr-TR')}`,
          grade: parseInt(grade),
          body: sanitizedText.trim(),
        });
        textId = tempText.id; // Use id for upload
        // Add to local texts list
        setTexts([tempText, ...texts]);
      } else if (selectedTextId) {
        // Find the selected text and use its id
        const selectedText = texts.find(t => t.id === selectedTextId);
        if (selectedText) {
          textId = selectedText.id;
        }
      }
      
      const response = await apiClient.uploadAudio(selectedFile, textId);
      
      // Add to analyses list immediately
      const newAnalysis = {
        id: response.analysis_id,
        created_at: new Date().toISOString(),
        status: 'queued',
        text_title: texts.find(t => t.id === selectedTextId)?.title || 'Unknown',
        audio_id: '',
      };
      addAnalysis(newAnalysis);
      
      // Start polling for status updates
      startPolling(response.analysis_id, async () => {
        try {
          const analysis = await apiClient.getAnalysis(response.analysis_id);
          updateAnalysis(response.analysis_id, { status: analysis.status });
          
          if (analysis.status === 'done' || analysis.status === 'failed') {
            // Reload full analysis data
            updateAnalysis(response.analysis_id, analysis);
            stopPolling(response.analysis_id);
          }
        } catch (error) {
          console.error('Failed to poll analysis status:', error);
          stopPolling(response.analysis_id);
        }
      });
      
      // Reset form
      setSelectedFile(null);
      setSelectedTextId('');
      setCustomText('');
      setGrade('');
      
      // Show success message
      setShowSuccess(true);
      setTimeout(() => setShowSuccess(false), 5000);
      
    } catch (error: any) {
      console.error('Failed to start analysis:', error);
      
      // More specific error messages
      let errorMessage = 'Analiz başlatılırken hata oluştu.';
      
      if (error.response?.status === 422) {
        errorMessage = 'Metin bilgileri eksik veya hatalı. Lütfen tüm alanları doldurun.';
      } else if (error.response?.status === 400) {
        errorMessage = 'Ses dosyası veya metin formatı desteklenmiyor.';
      } else if (error.response?.status === 413) {
        errorMessage = 'Dosya boyutu çok büyük. Lütfen daha küçük bir dosya seçin.';
      } else if (error.response?.status === 415) {
        errorMessage = 'Desteklenmeyen dosya türü. Lütfen ses dosyası seçin.';
      } else if (error.response?.status >= 500) {
        errorMessage = 'Sunucu hatası. Lütfen daha sonra tekrar deneyin.';
      } else if (!navigator.onLine) {
        errorMessage = 'İnternet bağlantınızı kontrol edin.';
      } else if (error.response?.data?.detail) {
        errorMessage = error.response.data.detail;
      }
      
      // Show error in a better way
      setFormErrors(prev => ({
        ...prev,
        file: errorMessage
      }));
    } finally {
      setIsUploading(false);
    }
  };


  const getStatusBadge = (status: string) => {
    const statusClasses = {
      queued: 'bg-gray-100 text-gray-800',
      running: 'bg-yellow-100 text-yellow-800',
      done: 'bg-green-100 text-green-800',
      failed: 'bg-red-100 text-red-800',
    };
    
    return (
      <span className={classNames('badge', statusClasses[status as keyof typeof statusClasses] || 'bg-gray-100 text-gray-800')}>
        {status}
      </span>
    );
  };

  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-indigo-600"></div>
      </div>
    );
  }

  // If not authenticated, don't render anything (will redirect)
  if (!isAuthenticated) {
    return null;
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white shadow">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center py-6">
            <div>
              <h1 className="text-3xl font-bold text-gray-900 flex items-center">
                <span className="text-3xl mr-3">📚</span>
                Okuma Analizi
              </h1>
              <p className="mt-1 text-sm text-gray-500">
                Ses dosyası yükleyin ve okuma analizi yapın
              </p>
            </div>
            <Navigation />
          </div>
        </div>
      </div>

      {/* Content */}
      <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="space-y-8">
          {/* Upload Section */}
          <div className="bg-white shadow rounded-lg">
            <div className="px-6 py-8">
              <h2 className="text-2xl font-semibold mb-8 text-center flex items-center justify-center">
                <span className="text-2xl mr-2">🎤</span>
                Ses Dosyası Analizi
              </h2>
        
        <div className="space-y-8">
          {/* File Upload */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-4">
              Ses Dosyası <span className="text-red-500">*</span>
            </label>
            <div
              className={classNames(
                'border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors',
                dragActive ? 'border-blue-400 bg-blue-50' : 'border-gray-300',
                selectedFile ? 'border-green-400 bg-green-50' : '',
                formErrors.file ? 'border-red-400 bg-red-50' : ''
              )}
              onDragEnter={handleDrag}
              onDragLeave={handleDrag}
              onDragOver={handleDrag}
              onDrop={handleDrop}
              onClick={() => document.getElementById('file-input')?.click()}
            >
              <input
                id="file-input"
                type="file"
                accept="audio/*,.mp3,.wav,.m4a,.aac,.ogg,.flac"
                onChange={handleFileSelect}
                className="hidden"
              />
              {selectedFile ? (
                <div>
                  <div className="text-green-600 text-4xl mb-2">🎵</div>
                  <p className="text-green-600 font-medium text-lg">{selectedFile.name}</p>
                  <p className="text-sm text-gray-500">Dosya seçildi - Analiz için hazır</p>
                </div>
              ) : (
                <div>
                  <div className="text-gray-400 text-4xl mb-2">📁</div>
                  <p className="text-gray-600 text-lg">Dosyayı buraya sürükleyin veya tıklayın</p>
                  <p className="text-sm text-gray-500">MP3, WAV, M4A desteklenir</p>
                </div>
              )}
            </div>
            {formErrors.file && (
              <p className="text-red-500 text-sm mt-2">{formErrors.file}</p>
            )}
          </div>
          
          {/* Text Selection */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Sınıf Seviyesi <span className="text-red-500">*</span>
              </label>
              <select
                value={grade}
                onChange={(e) => {
                  setGrade(e.target.value);
                  setSelectedTextId(''); // Reset selection when grade changes
                  // Clear grade error when user selects
                  if (formErrors.grade) {
                    setFormErrors(prev => ({ ...prev, grade: '' }));
                  }
                }}
                className={`select text-lg py-3 ${formErrors.grade ? 'border-red-500' : ''}`}
                style={{backgroundColor: grade === '' ? '#f9f9f9' : 'white'}}
              >
                <option value="">Sınıf seçiniz</option>
                <option value={1}>1. Sınıf</option>
                <option value={2}>2. Sınıf</option>
                <option value={3}>3. Sınıf</option>
                <option value={4}>4. Sınıf</option>
              </select>
              {formErrors.grade && (
                <p className="text-red-500 text-sm mt-1">{formErrors.grade}</p>
              )}
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Örnek Metin Seç
              </label>
              <select
                value={selectedTextId}
                onChange={(e) => setSelectedTextId(e.target.value)}
                className="select text-lg py-3"
                disabled={!grade || grade === ''}
              >
                <option value="">{grade && grade !== '' ? 'Metin seçiniz' : 'Önce sınıf seçiniz'}</option>
                {filteredTexts.map((text) => (
                  <option key={text.id} value={text.id}>
                    {text.title}
                  </option>
                ))}
              </select>
            </div>
          </div>
          
          {/* Target Text Input */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Hedef Metin <span className="text-red-500">*</span>
            </label>
            <textarea
              value={customText}
              onChange={(e) => {
                setCustomText(e.target.value);
                // Clear text error when user types
                if (formErrors.text) {
                  setFormErrors(prev => ({ ...prev, text: '' }));
                }
              }}
              placeholder="Analiz edilecek metni buraya yazın veya yukarıdan seçin..."
              className={`textarea h-32 text-lg ${formErrors.text ? 'border-red-500' : ''}`}
              maxLength={10000}
            />
            <div className="flex justify-between items-center mt-1">
              {formErrors.text && (
                <p className="text-red-500 text-sm">{formErrors.text}</p>
              )}
              <p className="text-sm text-gray-500 ml-auto">
                {customText.length}/10,000 karakter
              </p>
            </div>
            <p className="text-sm text-gray-500 mt-1">
              Metin seçtiyseniz otomatik doldurulur, isterseniz düzenleyebilirsiniz.
            </p>
          </div>
          
          {/* Analyze Button */}
          <div className="text-center">
            <button
              onClick={startAnalysis}
              disabled={!selectedFile || !customText.trim() || isUploading}
              className={classNames(
                'btn text-lg px-8 py-4',
                (!selectedFile || !customText.trim() || isUploading) 
                  ? 'btn-secondary' 
                  : 'btn-primary'
              )}
            >
              {isUploading ? (
                <div className="flex items-center">
                  <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-white mr-2"></div>
                  Analiz Ediliyor...
                </div>
              ) : (
                'Analiz Et'
              )}
            </button>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      {/* Success Message */}
      {showSuccess && (
        <div className="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg z-50">
          <div className="flex items-center">
            <div className="text-2xl mr-2">✅</div>
            <div>
              <div className="font-medium">Analiz Başlatıldı!</div>
              <div className="text-sm">Geçmiş Analizler sayfasından takip edebilirsiniz.</div>
            </div>
          </div>
        </div>
      )}
      
    </div>
  );
}
